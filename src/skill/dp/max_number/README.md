## Question

在一个数组 `arr` 中，找出一组**不相邻**的数字，使得最后的和最大。

示例：

```java
输入：arr = [4, 1, 1, 9, 1]

输出：res = 13

说明：当所选的各不相邻的数为：4、9 时和为最大。
```

## Solution

这类动态规划可以被划分为：“选”或者“不选”的问题。

我们用函数`opt(i)`代表为当下标为`i`时的最优解（即总和最大）。可以通过“选”或者“不选”下标为`6`的元素，从而分析出`opt(6)`的两种解：

- 选：如果选了第`6`个元素，则不能选相邻的第`5`个元素，则解为`s = opt(4) + arr[6]`；

- 不选：反之，则可以选择第`5`个元素。则解为：`s = opt(5)`

因此我们可以推到出**状态转移方程**为：

```java
opt(n) = Max(opt(n - 1) + arr[n], opt(n - 2))
```

再考虑**边界**的情况，即只有一个元素或者两个元素时：

- 一个元素：最优解（和最大）只能为 `arr[0]`；
- 两个元素：最优解取第一个与第二个元素较大的那位（它们其中其中只能二选一）；

```java
public static int dp(int[] arr) {
    int[] dp = new int[arr.length];
    int n = arr.length;

    dp[0] = arr[0];                   // 1个元素
    dp[1] = Math.max(arr[0], arr[1]); // 2个元素

    for (int i = 2; i < n; i++) {
        int a = dp[i - 2] + arr[i];
        int b = dp[i - 1];
        dp[i] = Math.max(a, b);
    }
    return dp[n - 1];
}
```